在 c + + 程序中，符号（例如变量或函数名）可以在其作用域内任意多次声明，但只能定义一次。 此规则为 "一项定义规则" （ODR）。 声明将一个名称引入（或重新引入）到程序中。 定义会引入一个名称。 如果名称表示一个变量，则定义会对其进行显式初始化。 函数定义包括签名和函数体。 类定义包含类名，后跟一个列出所有类成员的块。 （可以选择在另一个文件中单独定义成员函数的主体。）

下面的示例演示了一些声明：
```c++
int i;
int f(int x);
class C;
```
下面的示例演示了一些定义：
```c++
int i{42};
int f(int x){ return x * i; }
class C {
public:
   void DoSomething();
};
```
程序由一个或多个翻译单元组成。翻译单元由实现文件以及它直接或间接包含的所有标头组成。 实现文件通常具有cpp或 .cxx的文件扩展名。 标头文件通常具有h或hpp扩展名。 每个翻译单元都是由编译器单独编译的。编译完成后，链接器会将编译的翻译单元合并到一个程序中。ORD 规则的冲突通常显示为连接器错误。当同一名称在不同的翻译单元中具有两个不同的定义时，将发生链接错误。

通常，使变量在多个文件中可见的最佳方式是将其放在标头文件中。然后在每个需要声明的 cpp 文件中添加 #include 指令。通过在标头内容周围添加 include 防护，可以确保它声明的名称只定义一次。

# 外部和内部链接
Free 函数是在全局或命名空间范围中定义的函数。 非常量的全局变量和 free 函数默认情况下具有外部链接;它们在程序的任何翻译单元中可见。 因此，其他全局对象不能具有该名称。 带有内部链接的符号或没有链接的符号仅在声明它的翻译单元中可见。 如果名称具有内部链接，则同一名称可能存在于另一个翻译单元中。 在类定义或函数体中声明的变量没有链接。

可以通过将全局名称显式声明为静态，来强制全局名称具有内部链接。 这会将其可见性限制在声明它的同一转换单元中。 在这种情况下， static意味着应用于局部变量的情况有所不同。

默认情况下，下列对象具有内部链接：
1. const 对象
2. constexpr 对象
3. typedefs
4. 命名空间范围内的静态对象

若要为常量对象外部链接，请将其声明为 extern, 并为其分配一个值：
```c++
extern const int value = 42;
```