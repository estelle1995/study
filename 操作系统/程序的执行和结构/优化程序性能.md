# 优化编译器的能力和局限性
现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后它们利用一些机会来简化表达式，也就是在几个不同的地方使用一个计算，以降低一个给定的计算必须被执行的次数。编译器优化程序的能力受几个因素限制，包括：要求它们绝不能改变正确的程序行为；它们对程序行为、对使用它们的环境了解有限；需要很快地完成编译工作。编译器优化对用户来说应该是不可见的
```c
void twiddle1(int *xp, int *yp) {
    *xp += *yp;
    *xp += *yp;
}

void twiddle2(int *xp, int *yp) {
    *xp += 2 * *yp;
}
```
上述 twiddle2 比 twiddle1性能更好，考虑一下 xp 等于 yp 的情况 结果会是xp的值増加3倍。编译器不知道twiddlel会被如何调用，因此它必须假设参数xp和yp可能会相等。因此，它不能产生twiddle2风格的代码作为twiddlel的优化版本。 这个现象称为存储器别名使用(memoryaliasing)。编译器必须假设不同的指针可能会指向存储器中同一个位置。这造成了一个主要的妨碍优化的因素，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。

# 表示程序性能
我们需要一种方法来表示程序性能，它能指导我们改进代码。对许多程序都很有用的度量标准是每元素的周期数(cycles per element, CPE).这种度量标准帮助我们在更详细的级别上理解迭代程序的循环性能。同时，这样的度量标准对执行重复计算的程序来说也是很适当的，例如处理图像中的像素，或是计算矩阵乘积中的元素。

处理器活动的顺序是由时钟