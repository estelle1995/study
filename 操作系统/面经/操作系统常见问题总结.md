# 操作系统基础
## 什么是操作系统？
1. 操作系统是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石
2. 操作系统本质上是运行在计算机上的软件程序
3. 操作系统为用户提供一个与系统交互的操作界面
4. 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）

内核负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。内核就是操作系统背后黑盒的核心。


## 什么是系统调用
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
1. 用户态：用户态运行的进程或可以直接读取用户程序的数据。
2. 系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制

我们运行的程序基本都是运行在用户态，如果我们需要调用操作系统提供的系统态级别的子功能就需要系统调用了

也就是说在我们运行的用户程序中，凡是与系统级别的资源有关的操作（如文件管理、进程控制、内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：
1. 设备管理。完成设备的请求或释放，以及设备启动等功能。
2. 文件管理。完成文件的读、写、创建及删除等功能。
3. 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
4. 进程通信。完成进程之间的消息传递或信号传递等功能。
5. 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址功能/

# 进程和线程
## 进程和线程的区别


## 进程有哪几种状态？
1. 创建状态： 进程正在被创建，尚未到就绪状态。
2. 就绪状态： 进程已经处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行。
3. 运行状态： 进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
4. 阻塞状态： 又称为等待状态。进程正在等待某一时间而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
5. 结束状态： 进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

## 进程间的通信方式
大概有7种常见的进程间的通信方式
1. 管道/匿名管道（Pipes）： 用于具有亲缘关系的父子进程间或者兄弟进程之间的通信
2. 有名管道（Names Pipes）： 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. 信号（Signal）： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
4. 消息队列（Message Queuing）：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启（即操作系统重启）或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5. 信号量（Semaphores): 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. 共享内存（Shared memory）：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. 套接字（Sokects): 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## 线程间的同步方式
线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式
1. 互斥量(Mutex): 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键字和各种 Lock 都是这种机制。
2. 信号量(Semphares)： 它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. 事件（Event）：Wait/Notify 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较。

## 进程的调度算法
为了确定首先执行哪个进程以及最后执行哪个进程以实现 CPU 最大利用率
1. 先到先服务（FCFS）调度算法：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
2. 短作业优先（SJF）的调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
3. 时间片轮转调度算法：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
4. 多级反馈队列调度算法：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略长进程。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。
5. 优先级调度： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

### 多级反馈队列调度算法
1. 在采用 FB 的系统中，设置了多个不同优先级的就绪队列，并赋予各个队列大小不同的时间片，使优先级越高的时间片越小
2. 新就绪的进程总是进入最高级优先队列的队尾，并按 FCFS 原则等待调度算法；当轮到该进程执行时，若它能在规定的时间片内完成，便可准备撤离系统，否则将他转入第二级队列末尾，再同样按 FCFS 原则等待调度；如果它在第二级队列上运行一个时间片后仍未完成，再依次将它转入第三级队列，……，如此下去，当一个长作业从第一级队列降到最后一级队列时，便在该队列中采取 RR 算法运行。
3. 系统总是调度第一级队列中的进程执行，仅当第一级队列空时，才调度第二级上队列上的进程执行。以此类推，仅当第 1~（i - 1）级队列空时，才调度第 i 级队列上的程序执行。

FB 算法属于抢占调度方式，它能较好的满足终端型作业用户、短批处理作业用户和长批处理作业用户等各种类型用户的需要。

# 操作系统内存管理基础
## 操作系统的内存管理主要是做什么？
操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

## 常见的几种内存管理机制
简单分为连续分配管理方式和非连续分配管理方式两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如块式管理。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如 页式管理 和 段式管理。
1. 块式管理：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. 页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. 段式管理：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如，有主程序段 MAIN、子程序段X、数据段D 及 栈段S 等。段式管理通过段表对应逻辑地址和物理地址。
4. 段页式管理机制。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。

## 快表和多级页表
在分页内存管理中，很重要的两点是
1. 虚拟地址到物理地址的转换要快。
2. 解决虚拟地址空间大，页表也会很大的问题。

### 快表
为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引入了快表来加速虚拟地址到物理地址的转换。我们可以把块表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache， 它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：
1. 根据虚拟地址中的页号查快表；
2. 如果该页在快表中，直接从快表中读取相应的物理地址；
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

## 多级页表
引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章

多级页表如何节约内存：https://www.polarxiong.com/archives/多级页表如何节约内存.html

## 分页机制和分段机制的共同点和区别
**1. 共同点**

1. 分页机制和分段机制都是为了提高内存利用率，减少内存碎片
2. 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

**2. 区别**
1. 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
2. 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需求。

## 逻辑虚拟地址物理地址
