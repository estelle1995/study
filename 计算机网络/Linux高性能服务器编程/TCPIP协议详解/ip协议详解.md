本章主要介绍
1. IP头部信息
2. IP数据报的路由和转发

# IP 服务的特点
IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。

虽然IP数据报头部提供了一个标识字段，用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。

发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。

# IPv4 头部结构
## IPv4 头部结构
其长度通常为20字节，除非含有可变长的选项部分。
![IPv4头部结构](assets/IPv4头部结构.png)
1. 4位版本号指定IP协议的版本。对IPv4来说，其值是4。其他IPv4协议的扩展版本（如SIP协议和PIP协议）则具有不同的版本号
2. 4位头部长度标识该IP头部有多少个32bit字（IP头部长度最长为60字节）
3. 8位服务类型（Type Of Service， TOS）包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须设置为0）。4位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。比如像ssh和telnet这样的等了程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。
4. 16位总长度是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65535字节。但由于MTU（maximum transmission unit）的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报（或分片）的长度都远远没有达到最大值。接下来的3个字段则描述了如何实现分片。
5. 16位标识，唯一的标识主机发送的每一个数据报。其初始值由系统随机生成；每发送一个数据报，其值就加1.该值在数据报分片时被复制到每个分片中，因此一个数据报的所有分片都具有相同的标识值
6. 3位标志字段的第一位保留，第二位（DF）表示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位（MF， more fragment），除了数据报的最后一个分片外，其他分片都要把它置为1
7. 13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位（乘8）后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（这样才能保证后面的IP分片拥有一个合适的偏移值）。
8. 8位生存时间（Time To Live， TTL）是数据报达到目的地之前允许经过的路由器跳数。TTL值被发送端设置（常见的值是64）。数据报在转发过程中每经过一个路由，该值就被路由器减1.当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以防止数据陷入路由循环。
9. 8位协议（protocol）用来区分上层协议，/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。其中，ICMP是1，TCP是6，UDP是17.
10. 16位头部校验和由发送端填充，接收端对其使用CRC算法以检验IP数据报头部（仅检验头部）在传输过程是否损坏
11. 32位的源端IP地址和目的端IP地址用来标识数据的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论经过多少个中转路由器。
12. 选项字段

可用的IP选项包括（选项字段）
1. 记录路由（record route），吿诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样我们就可以跟踪數据报的传递路径.
2. 时间戳(time stamp),告诉每个路由器都将数据报转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样就可以测量途径路由之间数据报传输的时间。
3. 松散源路由选择（loose source routing）.指定一个路由器IP地址列表，数据报发送过程必须经过其中所有的路由器。
4. 严格源路由选择（strict source routing），和松散源路由选择类似，不过数据报只能经过被指定的路由器。

## 使用tcpdump观察IPv4头部结构
```
$ sudo tcpdump -ntx -i lo                                #抓取本地回路上的数据包
$ telnet 127.0.0.1                                       #开启另一个终端执行telnet命令登录本机
Tring 127.0.0.1...
Connected to 127.0.0.1...
Escape character is '^]'.
Ubuntu 9.10
ernest-laptop login: ernest                              #输入用户名并回车
Password:                                                #输入密码并回车
```
tcpdump输出的第一个数据包，其内容如代码清单2-1所示：
```
IP 127.0.0.1.41612 > 127.0.0.1.23: Flags [s], seq 3499745539, win 32792,
options [mss 16396, sackOK, TS val 40781017 ecr 0, nop, wscale 6], length 0
    0x0000: 4510 003c a5da 4000 4006 96cf 7f00 0001
    0x0010: 7f00 0001 a295 0017 d099 e103 0000 0000
    0x0020: a002 8018 fe30 0000 0204 400c 0402 080a
    0x0030: 0263 44d9 0000 0000 0103 0306
```

该数据包描述的是一个IP数据报.由于我们是使用telnet寰录本机的,所以IP致据报的源端IP地址和目的端IP地址都是“127.0.0.1". telnet K务器程序使用的端口号是23（参见/etc/services文件）,而telnet客户端程序使用临时端口号41621与服务器通信.关于临时端口号，“Flags"、“seq”、“win”和“options”搆述的都是TCP头部信息，“length"指出该IP数据报所携带的应用程序数据的长度。

这次抓包我们开启了 tcpdump的-x选项.使之输出致据包的二进制码.此致据包共包含60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据（length值为0）.现在我们分析IP头部的每个字节。
!IPv4头部各个字段详解](assets/IPv4头部各个字段详解.png)

# IP 路由
IP模块基本工作流程
![IP模块基本工作流程](assets/IP模块基本工作流程.png)
我们从右往左来分析上图，当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做CRC校验，确认无误之后就分析其头部的具体信息。

如果该IP数据报的头部设置了源站选路选项（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理该数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址，或者是广播地址，即该数据包是发送给本机的，则IP模块就根据数据报头部中的协议字段来决定将它派发给哪个上层应用（分用）。如果IP模块发现这个数据报不是发送给本机的，则也调用数据报转发子模块来处理该数据报。

数据报转发子模块将首先检测系统是否允许转发，如果不允许，IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报执行一些操作，然后将它交给IP数据报输出子模块。

IP数据报应该发送至哪个下一跳路由（或者目标机器），以及经过那个网卡来发送，就是IP路由过程。IP模块实现数据报路由的核心数据结构是路由表。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将被发往相同的下一跳路由器（或者目标机器）。

## 路由机制
我们可以使用route命令或netstat命令查看路由表，执行root命令得到以下内容：
```
Kernel IP routing table
Destination     Gateway         Genmask         Flags   Metric  Ref     Use     Iface
default         192.168.1.1     0.0.0.0         UG      0       0       0       eth0
192.168.1.0     *               255.255.255.0   U       1       0       0       eth0
```
第一项的目标地址是default，即所谓的默认路由项。该项包含一个“G”标志，说明路由的下一跳目标是网关，其地址是192.168.1.1（这是测试网络中路由器的本地IP地址）。另外一个路由项的目标地址是192.168.1.0，它指的是本地局域网。该路由项的网关地址为*，说明数据报不需要路由中转，可以直接发送到目标机器。

1. Destination  目标网络或主机
2. Gateway      网关地址，*表示目标和本机在同一网络，不需要路由
3. Genmask      网络掩码
4. Flags        路由项标志，常见标志有5种，（U，该路由项是活动的），（H，该路由项的目标是一台主机），（G，该路由项的目标是网关），（D，该路由项由重定向生成的），（M，该路由项被重定向修改过）
5. Metric       路由距离，即到达指定网络所需的中转数
6. Ref          路由项被引用的次数（Linux未使用）
7. Use          该路由项被使用的次数
8. Iface        该路由项对应的输出网卡接口

### IP的路由机制步骤
1. 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用该路由项，没找到则转步骤2.
2. 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址， 如果找到，就使用该路由项；没找到则转到步骤3
3. 选择默认路由项，这通常意味着数据报的下一跳路由是网关。

## 路由表更新
route命令可以修改路由表。
```
$ sudo route add -host 192.168.1.109 dev eth0
$ sudo route del -net 192.168.1.0 netmask 255.255.255.0
$ sudo route del default
$ sudo route add default gw 192.168.1.109 dev eth0
```
第1行表示添加主机192.168.1.109 （机器Kongming20）对应的路由项.这样设置之后，所有从emest-laptop发送到Kongming20的IP數据报将通过网卡ethO直接发送至目标机器的接收网卡.第2行表示删除网络192.168.1.0对应的路由项.这样，除了机器KongmingZO外，测试机器emest-laptop将无法访问该局域网上的任何其他机器（能访问到Kongming20是由于执行了上一条命令）.第3行表示原除默认路由项，这样做的后果是无法访何因特网.第4行表示重新设置默认路由项，不过这次其网关是机器KongmingZO （而不是能直接访问因特网的路由器）!经过上述修改后的路由表如下，
![](assets/路由表示例.png)

这个新的路由表中，第一个路由项是主机路由项，所以它被设置了“H”标志。我们设计这样一个路由表的目的是为了后文讨论ICMP重定向提供环境

通过route命令或其他工具手工修改路由表，是静态的路由更新方式。对于大型的路由器，它们通常通过BGP（Border Gateway Protocol， 边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、OSPF等协议来发现路径，并更新自己的路由表。这种更新方式是动态的、自动的。

# IP转发
不是发送给本机的IP数据报将由数据报转发子模块来处理。路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0.

对于允许IP数据报转发的系统（主机或路由器），数据报转发子模块将对期望转发的数据报执行如下操作：
1. 检查数据报头部的TTL值，如果TTL值已经是0，则丢弃该数据报。
2. 查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址.如果不是，则发送一个ICMP源站选路失败报文给发送端
3. 如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。
4. 将TTL值减1
5. 处理IP头部选项
6. 如果有必要，执行IP分片操作

# 重定向
## ICMP 重定向报文
![ICMP重定向报文格式](assets/ICMP重定向报文格式.png)
ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。主机重定向，其代码值为1.

ICMP 重定向报文的数据部分含义很明确很明确，它给接收方提供了如下两个信息
1. 引起重定向的IP数据报的源端IP地址
2. 应该使用的路由器的IP地址

接收主机根据这两个信息就可以断定引起重定向的IP数据报应该使用那个路由器来转发，并且以此来更新路由衰（通常是更新路由表缓冲，而不是直接更改路由表）.

/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文，而/proc/sys/net/ipv4/conf/all/accept_redirects内核参数则指定是否允许接收ICMP重定向报文。一般来说，主机只能接收ICMP重定向报文，而路由器只能发送ICMP重定向报文。

## 主机重定向实例
在上述学习中，我们把机器emest-laptop的网关设置成了机器Kongming20 使 KongmingZO的败据报转发功能，因此机器eraest-laptop将通过Kongming20来访问因特网.比如在emest-laptop上执行如下ping命令：
```
$ ping www.baidu.com
PING www.a.shifen.com (119.75.217.56) 56(84) bytes of data.
From Kongming20 (192.168.1.109) : icmp_seq = 1 Redirect Host(New Nesthop:192.168.1.1)
64 bytes from 119.75.217.56: icmp_seq = 1 ttl = 54 time = 6.78 ms

--- www.a.shifen.com ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 6.789/6.789/6.789/0.000ms
```

### 输入 ping IP 后敲回车，发包前会发生什么？
ping目标ip时，如果在相同网段直接先查询arp缓存，如果找到目标ip的mac地址，直接发送出去，如果缓存中查不到，则从相同网段的网卡发arp问目标ip的mac地址，拿到mac地址后发送出去。如果不在主机的网段里，会查询默认网关ip，接着查询arp缓存，是否有网关的mac地址记录，如果有，填充该mac地址，发送出去，如果没有，发arp问网关的mac地址，得到结果，发送出去。

# IPv6头部信息

## IPv6 固定头部结构
IPv6头部由40字节的固定头部和可变长的扩展头部组成。图2-6所示是IPv6的固定头部结构
![IPv6固定头部结构](assets/IPv6固定头部结构.png)
1. 4位版本号（version），指定IP协议的版本。对IPv6来说，其值是6
2. 8位通信类型（traffic class）指示数据流通信类型或优先级，和IPv4中的TOS类似
3. 20位流标签（flow label）是IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输。
4. 16位净荷长度（payload length）指的是IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度
5. 8位下一个包头（next header） 指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（TCP、UDP或ICMP）它类似于IPv4头部中的协议字段。
6. 8位跳数限制（hop limit）和IPv4中的TTL含义相同

## IPv6扩展头部
可变长的扩展头部使得IPv6能支持更多的选项，并且便于将来的扩展需要。它的长度可以是0，表示数据报没有使用任何扩展头部。一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部（固定头部或扩展头部）中的下一个报头字段指定。目前可以使用的扩展头部如下
1. Hop-by-Hop  逐跳选项头部，它包含每个路由器都必须检查和处理的特殊参数选项
2. Destination options 目的选项头部，指定由最终目的节点处理的选项
3. Routing 路由头部，指定数据报要经过哪些中转路由器，功能类似于IPv4的松散源路由选择选项和记录路由选项
4. Fragment  分片头部，处理分片和重组的细节
5. Authentication 认证头部，提供数据源认证、数据完整性检查和反重播保护
6. Encapsulation Security Payload  加密头部，提供加密服务
7. No next header 没有后续扩展头部

IPv4数据报的以太网帧封装类型值是0x800，而IPv6数据报的以太网帧封装类型值是0x86dd
